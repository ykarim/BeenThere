{"ast":null,"code":"//------------------------------------------------------------------------------\n// Copyright Jonathan Kaufman 2015\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//------------------------------------------------------------------------------\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar _d3 = require('d3');\n\nvar _d32 = _interopRequireDefault(_d3);\n/**\n * Properties defined during construction:\n *   svg\n *   html\n *   legend\n *   bubble\n *   diameter\n *   colorRange\n *   colorLegend\n *   selectedColor\n *   legendSpacing\n *   smallDiameter\n *   textColorRange\n *   mediumDiameter\n *   configureLegend\n *   selectedTextColor\n *   fontSizeFactor\n *   duration\n *   delay\n */\n\n\nvar ReactBubbleChartD3 = function () {\n  function ReactBubbleChartD3(el) {\n    var props = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, ReactBubbleChartD3);\n\n    this.legendSpacing = typeof props.legendSpacing === 'number' ? props.legendSpacing : 3;\n    this.selectedColor = props.selectedColor;\n    this.selectedTextColor = props.selectedTextColor;\n    this.smallDiameter = props.smallDiameter || 40;\n    this.mediumDiameter = props.mediumDiameter || 115;\n    this.fontSizeFactor = props.fontSizeFactor;\n    this.duration = props.duration === undefined ? 500 : props.duration;\n    this.delay = props.delay === undefined ? 7 : props.delay; // create an <svg> and <html> element - store a reference to it for later\n\n    this.svg = _d32['default'].select(el).append('svg').attr('class', 'bubble-chart-d3').style('overflow', 'visible');\n    this.html = _d32['default'].select(el).append('div').attr('class', 'bubble-chart-text').style('position', 'absolute').style('left', 0) // center horizontally\n    .style('right', 0).style('margin-left', 'auto').style('margin-right', 'auto');\n    this.legend = _d32['default'].select(el).append('svg').attr('class', 'bubble-legend').style('overflow', 'visible').style('position', 'absolute');\n    this.tooltip = this.html.append('div').attr('class', 'tooltip').style('position', 'absolute').style('border-radius', '5px').style('border', '3px solid').style('padding', '5px').style('z-index', 500); // create legend and update\n\n    this.adjustSize(el);\n    this.update(el, props);\n  }\n  /**\n   * Set this.diameter and this.bubble, also size this.svg and this.html\n   */\n\n\n  _createClass(ReactBubbleChartD3, [{\n    key: 'adjustSize',\n    value: function adjustSize(el) {\n      // helper values for positioning\n      this.diameter = Math.min(el.offsetWidth, el.offsetHeight);\n      var top = Math.max((el.offsetHeight - this.diameter) / 2, 0); // center some stuff vertically\n\n      this.svg.attr('width', this.diameter).attr('height', this.diameter).style('position', 'relative').style('top', top + 'px'); // center vertically\n\n      this.html.style('width', this.diameter + 'px').style('height', this.diameter + 'px').style('top', top + 'px'); // center vertically;\n      // create the bubble layout that we will use to position our bubbles\\\n\n      this.bubble = _d32['default'].layout.pack().sort(null).size([this.diameter, this.diameter]).padding(3);\n    }\n    /**\n     * Create and configure the legend\n     */\n\n  }, {\n    key: 'configureLegend',\n    value: function configureLegend(el, props) {\n      var _this = this;\n\n      this.createLegend = props.legend; // for each color in the legend, remove any existing, then\n      // create a g and set its transform\n\n      this.legend.selectAll('.legend-key').remove();\n      if (!this.createLegend) return;\n      var legendRectSize = Math.min((el.offsetHeight - 20 - (this.colorLegend.length - 1) * this.legendSpacing) / this.colorLegend.length, 18);\n      var legendHeight = this.colorLegend.length * (legendRectSize + this.legendSpacing) - this.legendSpacing;\n      this.legend.style('height', legendHeight + 'px').style('width', legendRectSize + 'px').style('top', (el.offsetHeight - legendHeight) / 2 + 'px').style('left', 60 + 'px');\n      var legendKeys = this.legend.selectAll('.legend-key').data(this.colorLegend).enter().append('g').attr('class', 'legend-key').attr('transform', function (d, i) {\n        var height = legendRectSize + _this.legendSpacing;\n        var vert = i * height;\n        return 'translate(' + 0 + ',' + vert + ')';\n      }); // for each <g> create a rect and have its color... be the color\n\n      legendKeys.append('rect').attr('width', legendRectSize).attr('height', legendRectSize).style('fill', function (c) {\n        return c.color;\n      }).style('stroke', function (c) {\n        return c.color;\n      }); // add necessary labels to the legend\n\n      legendKeys.append('text').attr('x', legendRectSize + 2).attr('y', legendRectSize - 4).text(function (c) {\n        return c.text;\n      });\n    }\n    /**\n     * Create and configure the tooltip\n     */\n\n  }, {\n    key: 'configureTooltip',\n    value: function configureTooltip(el, props) {\n      this.createTooltip = props.tooltip;\n      this.tooltipFunc = props.tooltipFunc; // remove all existing divs from the tooltip\n\n      this.tooltip.selectAll('div').remove(); // intialize the styling\n\n      this.tooltip.style('display', 'none');\n      if (!this.createTooltip) return; // normalize the prop formats\n\n      this.tooltipProps = (props.tooltipProps || []).map(function (tp) {\n        return typeof tp === 'string' ? {\n          css: tp,\n          prop: tp,\n          display: tp\n        } : tp;\n      }); // create a div for each of the tooltip props\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.tooltipProps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _step.value;\n          var css = _step$value.css;\n          var prop = _step$value.prop;\n          this.tooltip.append('div').attr('class', css);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator['return']) {\n            _iterator['return']();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * This is where the magic happens.\n     * Update the tooltip and legend.\n     * Set up and execute transitions of existing bubbles to new size/location/color.\n     * Create and initialize new bubbles.\n     * Remove old bubbles.\n     * Maintain consistencies between this.svg and this.html\n     */\n\n  }, {\n    key: 'update',\n    value: function update(el, props) {\n      var _this2 = this;\n\n      this.adjustSize(el); // initialize color legend values and color range values\n      // color range is just an array of the hex values\n      // color legend is an array of the color/text objects\n\n      var colorLegend = props.colorLegend || [];\n      this.colorRange = colorLegend.map(function (c) {\n        return typeof c === 'string' ? c : c.color;\n      });\n      this.colorLegend = colorLegend.slice(0).reverse().map(function (c) {\n        return typeof c === 'string' ? {\n          color: c\n        } : c;\n      });\n      this.textColorRange = colorLegend.map(function (c) {\n        return typeof c === 'string' ? '#000000' : c.textColor || '#000000';\n      });\n      this.configureLegend(el, props);\n      this.configureTooltip(el, props);\n      var data = props.data;\n      if (!data) return;\n      var fontFactor = this.fontSizeFactor;\n      var duration = this.duration;\n      var delay = this.delay; // define a color scale for our colorValues\n\n      var color = _d32['default'].scale.quantize().domain([props.fixedDomain ? props.fixedDomain.min : _d32['default'].min(data, function (d) {\n        return d.colorValue;\n      }), props.fixedDomain ? props.fixedDomain.max : _d32['default'].max(data, function (d) {\n        return d.colorValue;\n      })]).range(this.colorRange); // define a color scale for text town\n\n\n      var textColor = _d32['default'].scale.quantize().domain([props.fixedDomain ? props.fixedDomain.min : _d32['default'].min(data, function (d) {\n        return d.colorValue;\n      }), props.fixedDomain ? props.fixedDomain.max : _d32['default'].max(data, function (d) {\n        return d.colorValue;\n      })]).range(this.textColorRange); // generate data with calculated layout values\n\n\n      var nodes = this.bubble.nodes(data.length ? {\n        children: data\n      } : data).filter(function (d) {\n        return d.depth;\n      }); // filter out the outer bubble\n      // assign new data to existing DOM for circles and labels\n\n      var circles = this.svg.selectAll('circle').data(nodes, function (d) {\n        return 'g' + d._id;\n      });\n      var labels = this.html.selectAll('.bubble-label').data(nodes, function (d) {\n        return 'g' + d._id;\n      }); // update - this is created before enter.append. it only applies to updating nodes.\n      // create the transition on the updating elements before the entering elements\n      // because enter.append merges entering elements into the update selection\n      // for circles we transition their transform, r, and fill\n\n      circles.transition().duration(duration).delay(function (d, i) {\n        return i * delay;\n      }).attr('transform', function (d) {\n        return 'translate(' + d.x + ',' + d.y + ')';\n      }).attr('r', function (d) {\n        return d.r;\n      }).style('opacity', 1).style('fill', function (d) {\n        return d.selected ? _this2.selectedColor : color(d.colorValue);\n      }); // for the labels we transition their height, width, left, top, and color\n\n      labels.on('mouseover', this._tooltipMouseOver.bind(this, color, el)).transition().duration(duration).delay(function (d, i) {\n        return i * delay;\n      }).style('height', function (d) {\n        return 2 * d.r + 'px';\n      }).style('width', function (d) {\n        return 2 * d.r + 'px';\n      }).style('left', function (d) {\n        return d.x - d.r + 'px';\n      }).style('top', function (d) {\n        return d.y - d.r + 'px';\n      }).style('opacity', 1).style('color', function (d) {\n        return d.selected ? _this2.selectedTextColor : textColor(d.colorValue);\n      }).attr('class', function (d) {\n        var size;\n        if (2 * d.r < _this2.smallDiameter) size = 'small';else if (2 * d.r < _this2.mediumDiameter) size = 'medium';else size = 'large';\n        return 'bubble-label ' + size;\n      }) // we can pass in a fontSizeFactor here to set the label font-size as a factor of its corresponding circle's radius; this overrides CSS font-size styles set with the small, medium and large classes\n      .style('font-size', function (d) {\n        return fontFactor ? fontFactor * d.r + 'px' : null;\n      }); // enter - only applies to incoming elements (once emptying data)\n\n      if (nodes.length) {\n        // initialize new circles\n        circles.enter().append('circle').attr('transform', function (d) {\n          return 'translate(' + d.x + ',' + d.y + ')';\n        }).attr('r', 0).attr('class', function (d) {\n          return d.children ? 'bubble' : 'bubble leaf';\n        }).style('fill', function (d) {\n          return d.selected ? _this2.selectedColor : color(d.colorValue);\n        }).transition().duration(duration * 1.2).attr('transform', function (d) {\n          return 'translate(' + d.x + ',' + d.y + ')';\n        }).attr('r', function (d) {\n          return d.r;\n        }).style('opacity', 1); // intialize new labels\n\n        labels.enter().append('div').attr('class', function (d) {\n          var size;\n          if (2 * d.r < _this2.smallDiameter) size = 'small';else if (2 * d.r < _this2.mediumDiameter) size = 'medium';else size = 'large';\n          return 'bubble-label ' + size;\n        }).text(function (d) {\n          return d.displayText || d._id;\n        }).on('click', function (d, i) {\n          _d32['default'].event.stopPropagation();\n\n          props.onClick(d);\n        }).on('mouseover', this._tooltipMouseOver.bind(this, color, el)).on('mouseout', this._tooltipMouseOut.bind(this)).style('position', 'absolute').style('height', function (d) {\n          return 2 * d.r + 'px';\n        }).style('width', function (d) {\n          return 2 * d.r + 'px';\n        }).style('left', function (d) {\n          return d.x - d.r + 'px';\n        }).style('top', function (d) {\n          return d.y - d.r + 'px';\n        }).style('color', function (d) {\n          return d.selected ? _this2.selectedTextColor : textColor(d.colorValue);\n        }).style('opacity', 0).transition().duration(duration * 1.2).style('opacity', 1).style('font-size', function (d) {\n          return fontFactor ? fontFactor * d.r + 'px' : null;\n        });\n      } // exit - only applies to... exiting elements\n      // for circles have them shrink to 0 as they're flying all over\n\n\n      circles.exit().transition().duration(duration).attr('transform', function (d) {\n        var dy = d.y - _this2.diameter / 2;\n        var dx = d.x - _this2.diameter / 2;\n        var theta = Math.atan2(dy, dx);\n        var destX = _this2.diameter * (1 + Math.cos(theta)) / 2;\n        var destY = _this2.diameter * (1 + Math.sin(theta)) / 2;\n        return 'translate(' + destX + ',' + destY + ')';\n      }).attr('r', 0).remove(); // for text have them fade out as they're flying all over\n\n      labels.exit().transition().duration(duration).style('top', function (d) {\n        var dy = d.y - _this2.diameter / 2;\n        var dx = d.x - _this2.diameter / 2;\n        var theta = Math.atan2(dy, dx);\n        var destY = _this2.diameter * (1 + Math.sin(theta)) / 2;\n        return destY + 'px';\n      }).style('left', function (d) {\n        var dy = d.y - _this2.diameter / 2;\n        var dx = d.x - _this2.diameter / 2;\n        var theta = Math.atan2(dy, dx);\n        var destX = _this2.diameter * (1 + Math.cos(theta)) / 2;\n        return destX + 'px';\n      }).style('opacity', 0).style('width', 0).style('height', 0).remove();\n    }\n    /**\n     * On mouseover of a bubble, populate the tooltip with that elements info\n     * (if this.createTooltip is true of course)\n     */\n\n  }, {\n    key: '_tooltipMouseOver',\n    value: function _tooltipMouseOver(color, el, d, i) {\n      if (!this.createTooltip) return;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.tooltipProps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _step2.value;\n          var css = _step2$value.css;\n          var prop = _step2$value.prop;\n          var display = _step2$value.display;\n          this.tooltip.select('.' + css).html((display ? display + ': ' : '') + d[prop]);\n        } // Fade the popup fill mixing the shape fill with 80% white\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n            _iterator2['return']();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var fill = color(d.colorValue);\n\n      var backgroundColor = _d32['default'].rgb(_d32['default'].rgb(fill).r + 0.8 * (255 - _d32['default'].rgb(fill).r), _d32['default'].rgb(fill).g + 0.8 * (255 - _d32['default'].rgb(fill).g), _d32['default'].rgb(fill).b + 0.8 * (255 - _d32['default'].rgb(fill).b));\n\n      this.tooltip.style('display', 'block');\n      var tooltipNode = this.tooltip.node();\n\n      if (this.tooltipFunc) {\n        this.tooltipFunc(tooltipNode, d, fill);\n      }\n\n      var width = tooltipNode.offsetWidth + 1; // +1 for rounding reasons\n\n      var height = tooltipNode.offsetHeight;\n      var buffer = 5; // calculate where the top is going to be. ideally it is\n      // (d.y - height/2) which'll put the tooltip in the middle of the bubble.\n      // we need to account for if this'll put it out of bounds.\n\n      var top; // if it goes above the bounds, have the top be the buffer\n\n      if (d.y - height < 0) {\n        top = buffer; // if it goes below the bounds, have its buttom be a buffer length away\n      } else if (d.y + height / 2 > el.offsetHeight) {\n        top = el.offsetHeight - height - buffer; // otherwise smack this bad boy in the middle of its bubble\n      } else {\n        top = d.y - height / 2;\n      } // calculate where the left is going to be. ideally it is\n      // (d.x + d.r + buffer) which will put the tooltip to the right\n      // of the bubble. we need to account for the case where this puts\n      // the tooltip out of bounds.\n\n\n      var left; // if there's room to put it on the right of the bubble, do so\n\n      if (d.x + d.r + width + buffer < el.offsetWidth) {\n        left = d.x + d.r + buffer; // if there's room to put it on the left of the bubble, do so\n      } else if (d.x - d.r - width - buffer > 0) {\n        left = d.x - d.r - width - buffer; // otherwise put it on the right part of its container\n      } else {\n        left = el.offsetWidth - width - buffer;\n      }\n\n      this.tooltip.style('background-color', backgroundColor).style('border-color', fill).style('width', width + 'px').style('left', left + 'px').style('top', top + 'px');\n    }\n    /**\n     * On tooltip mouseout, hide the tooltip.\n     */\n\n  }, {\n    key: '_tooltipMouseOut',\n    value: function _tooltipMouseOut(d, i) {\n      if (!this.createTooltip) return;\n      this.tooltip.style('display', 'none').style('width', '').style('top', '').style('left', '');\n    }\n    /** Any necessary cleanup */\n\n  }, {\n    key: 'destroy',\n    value: function destroy(el) {}\n  }]);\n\n  return ReactBubbleChartD3;\n}();\n\nexports['default'] = ReactBubbleChartD3;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}